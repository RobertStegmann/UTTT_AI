# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_test')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_test')
    _test = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_test', [dirname(__file__)])
        except ImportError:
            import _test
            return _test
        try:
            _mod = imp.load_module('_test', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _test = swig_import_helper()
    del swig_import_helper
else:
    import _test
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

BOARDSIZE = _test.BOARDSIZE
GRIDSIZE = _test.GRIDSIZE
MAX_THREADS = _test.MAX_THREADS
ANYBOARD = _test.ANYBOARD
X_VAL = _test.X_VAL
O_VAL = _test.O_VAL
OPEN_VAL = _test.OPEN_VAL
STALEMATE = _test.STALEMATE
GAME_WON = _test.GAME_WON
NO_WIN = _test.NO_WIN
ROW_DIMENSION = _test.ROW_DIMENSION
COL_DIMENSION = _test.COL_DIMENSION
VICTORY_VALUE = _test.VICTORY_VALUE
MAX_MOVES = _test.MAX_MOVES
BOARD_VALUE = _test.BOARD_VALUE
GRID_VALUE = _test.GRID_VALUE
PLAYABLE_VALUE = _test.PLAYABLE_VALUE
STATESIZE = _test.STATESIZE
class CGameState(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CGameState, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CGameState, name)
    __repr__ = _swig_repr
    __swig_setmethods__["board"] = _test.CGameState_board_set
    __swig_getmethods__["board"] = _test.CGameState_board_get
    if _newclass:
        board = _swig_property(_test.CGameState_board_get, _test.CGameState_board_set)
    __swig_setmethods__["boardsWon"] = _test.CGameState_boardsWon_set
    __swig_getmethods__["boardsWon"] = _test.CGameState_boardsWon_get
    if _newclass:
        boardsWon = _swig_property(_test.CGameState_boardsWon_get, _test.CGameState_boardsWon_set)
    __swig_setmethods__["currentBoard"] = _test.CGameState_currentBoard_set
    __swig_getmethods__["currentBoard"] = _test.CGameState_currentBoard_get
    if _newclass:
        currentBoard = _swig_property(_test.CGameState_currentBoard_get, _test.CGameState_currentBoard_set)
    __swig_setmethods__["currentTurn"] = _test.CGameState_currentTurn_set
    __swig_getmethods__["currentTurn"] = _test.CGameState_currentTurn_get
    if _newclass:
        currentTurn = _swig_property(_test.CGameState_currentTurn_get, _test.CGameState_currentTurn_set)
    __swig_setmethods__["gameWon"] = _test.CGameState_gameWon_set
    __swig_getmethods__["gameWon"] = _test.CGameState_gameWon_get
    if _newclass:
        gameWon = _swig_property(_test.CGameState_gameWon_get, _test.CGameState_gameWon_set)

    def __init__(self):
        this = _test.new_CGameState()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _test.delete_CGameState
    __del__ = lambda self: None
CGameState_swigregister = _test.CGameState_swigregister
CGameState_swigregister(CGameState)

class Coord(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Coord, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Coord, name)
    __repr__ = _swig_repr
    __swig_setmethods__["board"] = _test.Coord_board_set
    __swig_getmethods__["board"] = _test.Coord_board_get
    if _newclass:
        board = _swig_property(_test.Coord_board_get, _test.Coord_board_set)
    __swig_setmethods__["row"] = _test.Coord_row_set
    __swig_getmethods__["row"] = _test.Coord_row_get
    if _newclass:
        row = _swig_property(_test.Coord_row_get, _test.Coord_row_set)
    __swig_setmethods__["column"] = _test.Coord_column_set
    __swig_getmethods__["column"] = _test.Coord_column_get
    if _newclass:
        column = _swig_property(_test.Coord_column_get, _test.Coord_column_set)

    def __init__(self):
        this = _test.new_Coord()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _test.delete_Coord
    __del__ = lambda self: None
Coord_swigregister = _test.Coord_swigregister
Coord_swigregister(Coord)

class MoveList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MoveList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MoveList, name)
    __repr__ = _swig_repr
    __swig_setmethods__["length"] = _test.MoveList_length_set
    __swig_getmethods__["length"] = _test.MoveList_length_get
    if _newclass:
        length = _swig_property(_test.MoveList_length_get, _test.MoveList_length_set)
    __swig_setmethods__["moves"] = _test.MoveList_moves_set
    __swig_getmethods__["moves"] = _test.MoveList_moves_get
    if _newclass:
        moves = _swig_property(_test.MoveList_moves_get, _test.MoveList_moves_set)

    def __init__(self):
        this = _test.new_MoveList()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _test.delete_MoveList
    __del__ = lambda self: None
MoveList_swigregister = _test.MoveList_swigregister
MoveList_swigregister(MoveList)

class Args(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Args, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Args, name)
    __repr__ = _swig_repr
    __swig_setmethods__["layers"] = _test.Args_layers_set
    __swig_getmethods__["layers"] = _test.Args_layers_get
    if _newclass:
        layers = _swig_property(_test.Args_layers_get, _test.Args_layers_set)
    __swig_setmethods__["coords"] = _test.Args_coords_set
    __swig_getmethods__["coords"] = _test.Args_coords_get
    if _newclass:
        coords = _swig_property(_test.Args_coords_get, _test.Args_coords_set)

    def __init__(self):
        this = _test.new_Args()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _test.delete_Args
    __del__ = lambda self: None
Args_swigregister = _test.Args_swigregister
Args_swigregister(Args)

class HeuristicVal(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HeuristicVal, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HeuristicVal, name)
    __repr__ = _swig_repr
    __swig_setmethods__["boardVal"] = _test.HeuristicVal_boardVal_set
    __swig_getmethods__["boardVal"] = _test.HeuristicVal_boardVal_get
    if _newclass:
        boardVal = _swig_property(_test.HeuristicVal_boardVal_get, _test.HeuristicVal_boardVal_set)
    __swig_setmethods__["gridVal"] = _test.HeuristicVal_gridVal_set
    __swig_getmethods__["gridVal"] = _test.HeuristicVal_gridVal_get
    if _newclass:
        gridVal = _swig_property(_test.HeuristicVal_gridVal_get, _test.HeuristicVal_gridVal_set)
    __swig_setmethods__["playableVal"] = _test.HeuristicVal_playableVal_set
    __swig_getmethods__["playableVal"] = _test.HeuristicVal_playableVal_get
    if _newclass:
        playableVal = _swig_property(_test.HeuristicVal_playableVal_get, _test.HeuristicVal_playableVal_set)
    __swig_setmethods__["maxRuns"] = _test.HeuristicVal_maxRuns_set
    __swig_getmethods__["maxRuns"] = _test.HeuristicVal_maxRuns_get
    if _newclass:
        maxRuns = _swig_property(_test.HeuristicVal_maxRuns_get, _test.HeuristicVal_maxRuns_set)
    __swig_setmethods__["index"] = _test.HeuristicVal_index_set
    __swig_getmethods__["index"] = _test.HeuristicVal_index_get
    if _newclass:
        index = _swig_property(_test.HeuristicVal_index_get, _test.HeuristicVal_index_set)
    __swig_setmethods__["montePolicy"] = _test.HeuristicVal_montePolicy_set
    __swig_getmethods__["montePolicy"] = _test.HeuristicVal_montePolicy_get
    if _newclass:
        montePolicy = _swig_property(_test.HeuristicVal_montePolicy_get, _test.HeuristicVal_montePolicy_set)
    __swig_setmethods__["threads"] = _test.HeuristicVal_threads_set
    __swig_getmethods__["threads"] = _test.HeuristicVal_threads_get
    if _newclass:
        threads = _swig_property(_test.HeuristicVal_threads_get, _test.HeuristicVal_threads_set)

    def __init__(self):
        this = _test.new_HeuristicVal()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _test.delete_HeuristicVal
    __del__ = lambda self: None
HeuristicVal_swigregister = _test.HeuristicVal_swigregister
HeuristicVal_swigregister(HeuristicVal)

class MCHuerArg(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MCHuerArg, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MCHuerArg, name)
    __repr__ = _swig_repr
    __swig_setmethods__["game"] = _test.MCHuerArg_game_set
    __swig_getmethods__["game"] = _test.MCHuerArg_game_get
    if _newclass:
        game = _swig_property(_test.MCHuerArg_game_get, _test.MCHuerArg_game_set)
    __swig_setmethods__["maxRuns"] = _test.MCHuerArg_maxRuns_set
    __swig_getmethods__["maxRuns"] = _test.MCHuerArg_maxRuns_get
    if _newclass:
        maxRuns = _swig_property(_test.MCHuerArg_maxRuns_get, _test.MCHuerArg_maxRuns_set)
    __swig_setmethods__["montePolicy"] = _test.MCHuerArg_montePolicy_set
    __swig_getmethods__["montePolicy"] = _test.MCHuerArg_montePolicy_get
    if _newclass:
        montePolicy = _swig_property(_test.MCHuerArg_montePolicy_get, _test.MCHuerArg_montePolicy_set)
    __swig_setmethods__["seed"] = _test.MCHuerArg_seed_set
    __swig_getmethods__["seed"] = _test.MCHuerArg_seed_get
    if _newclass:
        seed = _swig_property(_test.MCHuerArg_seed_get, _test.MCHuerArg_seed_set)
    __swig_setmethods__["eval"] = _test.MCHuerArg_eval_set
    __swig_getmethods__["eval"] = _test.MCHuerArg_eval_get
    if _newclass:
        eval = _swig_property(_test.MCHuerArg_eval_get, _test.MCHuerArg_eval_set)

    def __init__(self):
        this = _test.new_MCHuerArg()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _test.delete_MCHuerArg
    __del__ = lambda self: None
MCHuerArg_swigregister = _test.MCHuerArg_swigregister
MCHuerArg_swigregister(MCHuerArg)

class MCST_Args(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MCST_Args, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MCST_Args, name)
    __repr__ = _swig_repr
    __swig_setmethods__["rollout"] = _test.MCST_Args_rollout_set
    __swig_getmethods__["rollout"] = _test.MCST_Args_rollout_get
    if _newclass:
        rollout = _swig_property(_test.MCST_Args_rollout_get, _test.MCST_Args_rollout_set)
    __swig_setmethods__["maxRuns"] = _test.MCST_Args_maxRuns_set
    __swig_getmethods__["maxRuns"] = _test.MCST_Args_maxRuns_get
    if _newclass:
        maxRuns = _swig_property(_test.MCST_Args_maxRuns_get, _test.MCST_Args_maxRuns_set)
    __swig_setmethods__["c"] = _test.MCST_Args_c_set
    __swig_getmethods__["c"] = _test.MCST_Args_c_get
    if _newclass:
        c = _swig_property(_test.MCST_Args_c_get, _test.MCST_Args_c_set)
    __swig_setmethods__["threads"] = _test.MCST_Args_threads_set
    __swig_getmethods__["threads"] = _test.MCST_Args_threads_get
    if _newclass:
        threads = _swig_property(_test.MCST_Args_threads_get, _test.MCST_Args_threads_set)
    __swig_setmethods__["shuffle"] = _test.MCST_Args_shuffle_set
    __swig_getmethods__["shuffle"] = _test.MCST_Args_shuffle_get
    if _newclass:
        shuffle = _swig_property(_test.MCST_Args_shuffle_get, _test.MCST_Args_shuffle_set)
    __swig_setmethods__["bias"] = _test.MCST_Args_bias_set
    __swig_getmethods__["bias"] = _test.MCST_Args_bias_get
    if _newclass:
        bias = _swig_property(_test.MCST_Args_bias_get, _test.MCST_Args_bias_set)
    __swig_setmethods__["scale"] = _test.MCST_Args_scale_set
    __swig_getmethods__["scale"] = _test.MCST_Args_scale_get
    if _newclass:
        scale = _swig_property(_test.MCST_Args_scale_get, _test.MCST_Args_scale_set)
    __swig_setmethods__["bias_multiplier"] = _test.MCST_Args_bias_multiplier_set
    __swig_getmethods__["bias_multiplier"] = _test.MCST_Args_bias_multiplier_get
    if _newclass:
        bias_multiplier = _swig_property(_test.MCST_Args_bias_multiplier_get, _test.MCST_Args_bias_multiplier_set)

    def __init__(self):
        this = _test.new_MCST_Args()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _test.delete_MCST_Args
    __del__ = lambda self: None
MCST_Args_swigregister = _test.MCST_Args_swigregister
MCST_Args_swigregister(MCST_Args)

class MonteCarloNode(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MonteCarloNode, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MonteCarloNode, name)
    __repr__ = _swig_repr
    __swig_setmethods__["game"] = _test.MonteCarloNode_game_set
    __swig_getmethods__["game"] = _test.MonteCarloNode_game_get
    if _newclass:
        game = _swig_property(_test.MonteCarloNode_game_get, _test.MonteCarloNode_game_set)
    __swig_setmethods__["parent"] = _test.MonteCarloNode_parent_set
    __swig_getmethods__["parent"] = _test.MonteCarloNode_parent_get
    if _newclass:
        parent = _swig_property(_test.MonteCarloNode_parent_get, _test.MonteCarloNode_parent_set)
    __swig_setmethods__["possibleMoves"] = _test.MonteCarloNode_possibleMoves_set
    __swig_getmethods__["possibleMoves"] = _test.MonteCarloNode_possibleMoves_get
    if _newclass:
        possibleMoves = _swig_property(_test.MonteCarloNode_possibleMoves_get, _test.MonteCarloNode_possibleMoves_set)
    __swig_setmethods__["children"] = _test.MonteCarloNode_children_set
    __swig_getmethods__["children"] = _test.MonteCarloNode_children_get
    if _newclass:
        children = _swig_property(_test.MonteCarloNode_children_get, _test.MonteCarloNode_children_set)
    __swig_setmethods__["move"] = _test.MonteCarloNode_move_set
    __swig_getmethods__["move"] = _test.MonteCarloNode_move_get
    if _newclass:
        move = _swig_property(_test.MonteCarloNode_move_get, _test.MonteCarloNode_move_set)
    __swig_setmethods__["childNum"] = _test.MonteCarloNode_childNum_set
    __swig_getmethods__["childNum"] = _test.MonteCarloNode_childNum_get
    if _newclass:
        childNum = _swig_property(_test.MonteCarloNode_childNum_get, _test.MonteCarloNode_childNum_set)
    __swig_setmethods__["N"] = _test.MonteCarloNode_N_set
    __swig_getmethods__["N"] = _test.MonteCarloNode_N_get
    if _newclass:
        N = _swig_property(_test.MonteCarloNode_N_get, _test.MonteCarloNode_N_set)
    __swig_setmethods__["T"] = _test.MonteCarloNode_T_set
    __swig_getmethods__["T"] = _test.MonteCarloNode_T_get
    if _newclass:
        T = _swig_property(_test.MonteCarloNode_T_get, _test.MonteCarloNode_T_set)
    __swig_setmethods__["heuristic"] = _test.MonteCarloNode_heuristic_set
    __swig_getmethods__["heuristic"] = _test.MonteCarloNode_heuristic_get
    if _newclass:
        heuristic = _swig_property(_test.MonteCarloNode_heuristic_get, _test.MonteCarloNode_heuristic_set)
    __swig_setmethods__["ID"] = _test.MonteCarloNode_ID_set
    __swig_getmethods__["ID"] = _test.MonteCarloNode_ID_get
    if _newclass:
        ID = _swig_property(_test.MonteCarloNode_ID_get, _test.MonteCarloNode_ID_set)

    def __init__(self):
        this = _test.new_MonteCarloNode()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _test.delete_MonteCarloNode
    __del__ = lambda self: None
MonteCarloNode_swigregister = _test.MonteCarloNode_swigregister
MonteCarloNode_swigregister(MonteCarloNode)

class RolloutArg(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RolloutArg, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RolloutArg, name)
    __repr__ = _swig_repr
    __swig_setmethods__["game"] = _test.RolloutArg_game_set
    __swig_getmethods__["game"] = _test.RolloutArg_game_get
    if _newclass:
        game = _swig_property(_test.RolloutArg_game_get, _test.RolloutArg_game_set)
    __swig_setmethods__["player"] = _test.RolloutArg_player_set
    __swig_getmethods__["player"] = _test.RolloutArg_player_get
    if _newclass:
        player = _swig_property(_test.RolloutArg_player_get, _test.RolloutArg_player_set)
    __swig_setmethods__["policy"] = _test.RolloutArg_policy_set
    __swig_getmethods__["policy"] = _test.RolloutArg_policy_get
    if _newclass:
        policy = _swig_property(_test.RolloutArg_policy_get, _test.RolloutArg_policy_set)
    __swig_setmethods__["seed"] = _test.RolloutArg_seed_set
    __swig_getmethods__["seed"] = _test.RolloutArg_seed_get
    if _newclass:
        seed = _swig_property(_test.RolloutArg_seed_get, _test.RolloutArg_seed_set)
    __swig_setmethods__["result"] = _test.RolloutArg_result_set
    __swig_getmethods__["result"] = _test.RolloutArg_result_get
    if _newclass:
        result = _swig_property(_test.RolloutArg_result_get, _test.RolloutArg_result_set)

    def __init__(self):
        this = _test.new_RolloutArg()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _test.delete_RolloutArg
    __del__ = lambda self: None
RolloutArg_swigregister = _test.RolloutArg_swigregister
RolloutArg_swigregister(RolloutArg)


def countTopLeft(foo):
    return _test.countTopLeft(foo)
countTopLeft = _test.countTopLeft

def countTopCentre(foo):
    return _test.countTopCentre(foo)
countTopCentre = _test.countTopCentre

def countCentre(foo):
    return _test.countCentre(foo)
countCentre = _test.countCentre

def countFromStartWrapper(arg):
    return _test.countFromStartWrapper(arg)
countFromStartWrapper = _test.countFromStartWrapper

def countFromStartWrapperLayers(arg):
    return _test.countFromStartWrapperLayers(arg)
countFromStartWrapperLayers = _test.countFromStartWrapperLayers

def countFromStart(board, row, column):
    return _test.countFromStart(board, row, column)
countFromStart = _test.countFromStart

def countFromStartLayers(board, row, column, layers):
    return _test.countFromStartLayers(board, row, column, layers)
countFromStartLayers = _test.countFromStartLayers

def countTopLeftLayers(mLayers):
    return _test.countTopLeftLayers(mLayers)
countTopLeftLayers = _test.countTopLeftLayers

def countTopCentreLayers(mLayers):
    return _test.countTopCentreLayers(mLayers)
countTopCentreLayers = _test.countTopCentreLayers

def countCentreLayers(mLayers):
    return _test.countCentreLayers(mLayers)
countCentreLayers = _test.countCentreLayers

def createCGameState():
    return _test.createCGameState()
createCGameState = _test.createCGameState

def cloneCGameState(game):
    return _test.cloneCGameState(game)
cloneCGameState = _test.cloneCGameState

def freeCGameState(game):
    return _test.freeCGameState(game)
freeCGameState = _test.freeCGameState

def isValidMove(game, board, row, column):
    return _test.isValidMove(game, board, row, column)
isValidMove = _test.isValidMove

def isBoardWon(game, board, row, column):
    return _test.isBoardWon(game, board, row, column)
isBoardWon = _test.isBoardWon

def isGameWon(game, board):
    return _test.isGameWon(game, board)
isGameWon = _test.isGameWon

def playTurn(game, board, row, column):
    return _test.playTurn(game, board, row, column)
playTurn = _test.playTurn

def countMoves(game):
    return _test.countMoves(game)
countMoves = _test.countMoves

def countMovesLayers(game, layers):
    return _test.countMovesLayers(game, layers)
countMovesLayers = _test.countMovesLayers

def chooseMoveFullBoard(game):
    return _test.chooseMoveFullBoard(game)
chooseMoveFullBoard = _test.chooseMoveFullBoard

def chooseMoveSingleGrid(game, board):
    return _test.chooseMoveSingleGrid(game, board)
chooseMoveSingleGrid = _test.chooseMoveSingleGrid

def getMoves(game):
    return _test.getMoves(game)
getMoves = _test.getMoves

def revertTurn(game, board, row, column, previousBoard):
    return _test.revertTurn(game, board, row, column, previousBoard)
revertTurn = _test.revertTurn

def chooseMoveListSingleGrid(game, moves, board):
    return _test.chooseMoveListSingleGrid(game, moves, board)
chooseMoveListSingleGrid = _test.chooseMoveListSingleGrid

def chooseMoveListFullBoard(game, moves):
    return _test.chooseMoveListFullBoard(game, moves)
chooseMoveListFullBoard = _test.chooseMoveListFullBoard

def getMovesList(game, moves):
    return _test.getMovesList(game, moves)
getMovesList = _test.getMovesList

def shuffleMoveList(list):
    return _test.shuffleMoveList(list)
shuffleMoveList = _test.shuffleMoveList

def shuffleMoves(moves, moveCount):
    return _test.shuffleMoves(moves, moveCount)
shuffleMoves = _test.shuffleMoves

def trimMoves(moves, length):
    return _test.trimMoves(moves, length)
trimMoves = _test.trimMoves

def copyCGameState(copy, original):
    return _test.copyCGameState(copy, original)
copyCGameState = _test.copyCGameState

def evaluateBoard(game, val):
    return _test.evaluateBoard(game, val)
evaluateBoard = _test.evaluateBoard

def evaluateGrid(game, grid, val):
    return _test.evaluateGrid(game, grid, val)
evaluateGrid = _test.evaluateGrid

def staticHeuristic(game, val):
    return _test.staticHeuristic(game, val)
staticHeuristic = _test.staticHeuristic

def staticHeuristicWrapper(game, val):
    return _test.staticHeuristicWrapper(game, val)
staticHeuristicWrapper = _test.staticHeuristicWrapper

def minimax(game, depth, alpha, beta, maximize, heuristic, val):
    return _test.minimax(game, depth, alpha, beta, maximize, heuristic, val)
minimax = _test.minimax

def minimaxWrapper(game, depth, alpha, beta, maximize, val):
    return _test.minimaxWrapper(game, depth, alpha, beta, maximize, val)
minimaxWrapper = _test.minimaxWrapper

def evaluateAndRecordBoard(game, boardRelevance, val):
    return _test.evaluateAndRecordBoard(game, boardRelevance, val)
evaluateAndRecordBoard = _test.evaluateAndRecordBoard

def evaluateGridAndRecord(game, grid, winnable, val):
    return _test.evaluateGridAndRecord(game, grid, winnable, val)
evaluateGridAndRecord = _test.evaluateGridAndRecord

def playableBoardHeuristic(game, val):
    return _test.playableBoardHeuristic(game, val)
playableBoardHeuristic = _test.playableBoardHeuristic

def playableBoardHeuristicWrapper(game, val):
    return _test.playableBoardHeuristicWrapper(game, val)
playableBoardHeuristicWrapper = _test.playableBoardHeuristicWrapper

def randomMove(game):
    return _test.randomMove(game)
randomMove = _test.randomMove

def chooseRandomMove(game, moves):
    return _test.chooseRandomMove(game, moves)
chooseRandomMove = _test.chooseRandomMove

def chooseWinningMove(game, moves):
    return _test.chooseWinningMove(game, moves)
chooseWinningMove = _test.chooseWinningMove

def chooseWinLose(game, moves):
    return _test.chooseWinLose(game, moves)
chooseWinLose = _test.chooseWinLose

def simulateGame(game, policy):
    return _test.simulateGame(game, policy)
simulateGame = _test.simulateGame

def monteCarloHeuristic(game, val):
    return _test.monteCarloHeuristic(game, val)
monteCarloHeuristic = _test.monteCarloHeuristic

def monteCarloHeuristicWrapper(game, val):
    return _test.monteCarloHeuristicWrapper(game, val)
monteCarloHeuristicWrapper = _test.monteCarloHeuristicWrapper

def getHeuristicDouble(game, args, player):
    return _test.getHeuristicDouble(game, args, player)
getHeuristicDouble = _test.getHeuristicDouble

def monteCarloTreeSearch(game, args):
    return _test.monteCarloTreeSearch(game, args)
monteCarloTreeSearch = _test.monteCarloTreeSearch

def intializeRoot(root, game, args, player):
    return _test.intializeRoot(root, game, args, player)
intializeRoot = _test.intializeRoot

def createNode(game, parent, move, args, player):
    return _test.createNode(game, parent, move, args, player)
createNode = _test.createNode

def expand(node, args, player):
    return _test.expand(node, args, player)
expand = _test.expand

def traverse(node, args, player):
    return _test.traverse(node, args, player)
traverse = _test.traverse

def calcUCB(node, args):
    return _test.calcUCB(node, args)
calcUCB = _test.calcUCB

def rollout(node, player, args):
    return _test.rollout(node, player, args)
rollout = _test.rollout

def backpropogate(node, result):
    return _test.backpropogate(node, result)
backpropogate = _test.backpropogate

def freeMonteCarloTree(root):
    return _test.freeMonteCarloTree(root)
freeMonteCarloTree = _test.freeMonteCarloTree

def freeMonteCarloNode(node):
    return _test.freeMonteCarloNode(node)
freeMonteCarloNode = _test.freeMonteCarloNode

def rollout_thread(r_arg):
    return _test.rollout_thread(r_arg)
rollout_thread = _test.rollout_thread

def simulateGame_thread(game, policy, buf):
    return _test.simulateGame_thread(game, policy, buf)
simulateGame_thread = _test.simulateGame_thread

def chooseWinLose_thread(game, moves, buf):
    return _test.chooseWinLose_thread(game, moves, buf)
chooseWinLose_thread = _test.chooseWinLose_thread

def chooseWinningMove_thread(game, moves, buf):
    return _test.chooseWinningMove_thread(game, moves, buf)
chooseWinningMove_thread = _test.chooseWinningMove_thread

def chooseRandomMove_thread(game, moves, buf):
    return _test.chooseRandomMove_thread(game, moves, buf)
chooseRandomMove_thread = _test.chooseRandomMove_thread

def monteCarloHeuristic_thread(args):
    return _test.monteCarloHeuristic_thread(args)
monteCarloHeuristic_thread = _test.monteCarloHeuristic_thread

def getID(game):
    return _test.getID(game)
getID = _test.getID

def setID(node):
    return _test.setID(node)
setID = _test.setID

def updateRoot(game, prev_root):
    return _test.updateRoot(game, prev_root)
updateRoot = _test.updateRoot

def initialize():
    return _test.initialize()
initialize = _test.initialize

def freeTree(prev_root):
    return _test.freeTree(prev_root)
freeTree = _test.freeTree

def freeUnused(node, ID):
    return _test.freeUnused(node, ID)
freeUnused = _test.freeUnused

def monteCarloTreeSearch_sf(game, args, prev_root):
    return _test.monteCarloTreeSearch_sf(game, args, prev_root)
monteCarloTreeSearch_sf = _test.monteCarloTreeSearch_sf

def intializeRoot_sf(root, game, args, player):
    return _test.intializeRoot_sf(root, game, args, player)
intializeRoot_sf = _test.intializeRoot_sf
# This file is compatible with both classic and new-style classes.


